### SPRITES

Today we're going to keep developing our game characters. So far, we've learned to animate our characters in a pretty simple way: we take an image or an illustration and we move it around the screen. But, our characters don't really look like they're moving, they just look like images that are moving on the screen. And, our game over state isn't great either, it just sort of happens. Shouldn't there be some sort of transition? Well, today we'll look at some ways to handle those things.

To begin, I want you to do the work. I've given you a starter [sketch](https://github.com/socalledsound/SE-unit2-day13-alien/tree/01-starter). In it, you'll find a folder with a set of images and an empty sketch loaded with the p5 library. So everything is all ready to go. I want you to figure out how to animate those images, using what you already know! Don't worry, I've got more for you, but I'm not going to give it to you just yet! Get to work. I'll be here to talk things through with you and when we're done, we'll move on.

![dancing alien](https://res.cloudinary.com/chris-kubick/image/upload/v1601955915/side-effects/alien6_tkoi8y.png)

Ok, here's my [code](https://github.com/socalledsound/SE-unit2-day13-alien/tree/02-finished).

It's just one way to do it, though! There are many others.

One really HUGE concept that I want to make sure you remember from this code (which we just did together in class) is the concept of a modulo, which is often used to constrain the value of a counter in a loop, by generating a remainder each time through a loop. In my draw loop I write

```
function draw() {
  background(220);
  image(imgArray[counter%numImgs], x, y, 250, 250);
  counter++
}

```

What this does is, constrain the value of counter to numImgs. Up to the value of numImgs, the remainder will be the value of counter. Above the value of numImgs, the remainder will reset to zero and continue up to the value of numImgs again. And again. Super useful! You'll see it a lot today, and hopefully get comfortable using it.

One of muy favorite [videos](https://www.youtube.com/watch?v=r5Iy3v1co0A) on the topic of modulo was made by an artist named Golan Levin, for Daniel Shiffman's show on youtube. Check it out, I also linked to it on today's syllabus. I'm going to link to videos by Daniel a lot this unit! He's really the Bob Ross of p5, and his videos are amazing.

Just for fun, have a look at this [code](https://editor.p5js.org/socalledsound/sketches/KsPjzaFSH).

I wrote it for this class a few years ago, it's kind of dumb but maybe it's a good example of a class in action? The class here, called FluffyMover, let's me bundle a bunch of characteristics into this thing called a fluffyMover, that has an image and sound attached to it. It also has a lifecycle, see where I give each one a somewhat random lifespan (in milliseconds) and a time born by saying

```
this.lifeSpan = random(5000,15000);
this.bornTime = millis();

```

and then in the draw loop, every time I call fluffyMover.update(), I get the current time and check to see if the fluffy should be recharacterized as no longer alive:

```
  if(this.currentTime - this.bornTime > this.lifeSpan){
      this.alive = false;

    }


```

And then I stop showing it, stop playing the sound and actually splice the fluffy from the array of fluffies, if it's no longer alive.

Another little chunk of code I want you to take a look at is [this](https://editor.p5js.org/socalledsound/sketches/BkEc6TIO7) simple sound and image animation.

The main tools I'm using here are setTimeout and setInterval, two timing functions that are built into the browser. SetTimeout does something after a specified period. We pass it a function and a time value in milliseconds, like this:

```
setTimeout( aFunction, 1000);

```

SetInterval is similar, but it will do something at a set interval. Both are pretty useful! I put a video describing how to use each one on today's syllabus if you want more on those.

In this sketch, you can also see how easy it is to make music with p5 with the help of these timing functions! All of those sounds are generated by oscillators in p5.

But, anyway...let's get down to sprite sheets.

I've borrowed this code from a video that Daniel Shiffman made. You can see the video [here](https://thecodingtrain.com/CodingChallenges/111-animated-sprite.html), and download his code from there if you want to. But you might find my code to be just a little easier to understand at first, I've added a few comments and simplified it just a little, he makes an array of horse animations and I just make one. You can get it from our course repo [here](https://github.com/socalledsound/SE-unit2-day13-spritesheet/tree/master).

I'm going to take his code as my starter code and then load in my own sprite.

You can see that his code uses a class called Sprite, which is in a seperate file. In that file, we use the modulo to keep an index value in range:

```
  //notice the use of modulo to keeop the value of index in range of the number of images, ie this.len.....
  show() {
    let index = floor(this.index) % this.len;
    image(this.animation[index], this.x, this.y);
  }

```

and we increment this index along with an x value, making sure to keep x on the screen by reseting it to zero if it gets past the edge of the page

```
  animate() {
    //increment the index and the position of x
    this.index += this.speed;
    this.x += this.speed * 15;
    //if this.x exceeds the screen, send it back to the beginning of the screen.....
    if (this.x > width) {
      this.x = -this.w;
    }
  }

```

Then in our main code, we call these two functions inside the draw loop:

```
  horse.show();
  horse.animate();

```

If you want to, you can uncomment Daniel's code where he makes an array of these sprites, I just took that out to simplify things a bit for now.

The thing I really want to focus on is, how we load our spritesheet, which is kind of annoying. He doesn't talk about it much in his video, but to load your own in, you'll have to modify the two files that we load in in preload, the actual spritesheet, which is a .png file, and the spritedata, which is a .json file.

.json is the basic data storage medium of the internet. JSON is a little like any other javascript object -- it stands for Javascript Standard Object Notation, after all -- but it's just a little more persnickety. You have to be very careful with your commas. Let's take a look at the horse one now, and then I'll show you one that I made for my own spritesheet.

JSON, like all javascript objects, works on this idea of key value pairs. But as you can see below, we need to actually put our keys in quotes:

```
{
  "frames": [{
      "name": "sprite-00",
      "position": {
        "x": 0,
        "y": 0,
        "w": 192,
        "h": 144
      }
    },
    {
      "name": "sprite-01",
      "position": {
        "x": 192,
        "y": 0,
        "w": 192,
        "h": 144
      }
    }
    ]
}


```

That code is just the first two frames, putting them all wouyld have been too long. You can see we have an array called 'frames', which holds, in this case, two objects. Eacgh one is a frame of the animation. Each frame is an object with two keys: a name, and 'position' object, which stores four variables, one each for x, y, w, and h.

In our code, we bring this whole data structure in and then we use a for loop to get a chunk of the image for each 'position', using p5's image.get() function.

```
  for (let i = 0; i < frames.length; i++) {
    let pos = frames[i].position;
    let img = spritesheet.get(pos.x, pos.y, pos.w, pos.h);
    animation.push(img);
  }

```

Make sense?

So, in order to use our own spritesheet, we need to change the JSON file to match our own spritesheet, and also load that spritesheet in.

I made a simple one, using piskel, I hope you did too. I'm going to take mine and load it in now. First, the easy part:

```
 function preload() {
  spritedata = loadJSON('abstract/abstract.json');
  spritesheet = loadImage('abstract/abstract.png');
}
```

I copied the horse.json into a new file called abstract.json and put it in a folder called abstract, with my spritesheet.

You can try just loading that in to your project, without changing the JSON; mine looks ALL WRONG, because, my image size is much smaller.

So the first thing I have to do is do some calculations. My overall image is a measly 128 x 128. and it's broken up into a 4x4 grid, but the last row is empty, I only have 12 images.

So each image should be about 32 x 32.

And my first JSON frame should look like this :

```
      "name": "sprite-00",
      "position": {
        "x": 0,
        "y": 0,
        "w": 32,
        "h": 32
      }
    },

```

Now for each frame I just have to increment the x and y values, across and then down the screen. Here's my finished JSON file:

```
{
  "frames": [
    {
      "name": "sprite-00",
      "position": {
        "x": 0,
        "y": 0,
        "w": 32,
        "h": 32
      }
    },
    {
      "name": "sprite-01",
      "position": {
        "x": 32,
        "y": 0,
        "w": 32,
        "h": 32
      }
    },
    {
      "name": "sprite-02",
      "position": {
        "x": 64,
        "y": 0,
        "w": 32,
        "h": 32
      }
    },
    {
      "name": "sprite-03",
      "position": {
        "x": 96,
        "y": 0,
        "w": 32,
        "h": 32
      }
    },
    {
      "name": "sprite-04",
      "position": {
        "x": 0,
        "y": 32,
        "w": 32,
        "h": 32
      }
    },
    {
      "name": "sprite-05",
      "position": {
        "x": 32,
        "y": 32,
        "w": 32,
        "h": 32
      }
    },
    {
      "name": "sprite-06",
      "position": {
        "x": 64,
        "y": 32,
        "w": 32,
        "h": 32
      }
    },
    {
      "name": "sprite-07",
      "position": {
        "x": 96,
        "y": 32,
        "w": 32,
        "h": 32
      }
    },
    {
      "name": "sprite-08",
      "position": {
        "x": 0,
        "y": 64,
        "w": 32,
        "h": 32
      }
    },
    {
      "name": "sprite-09",
      "position": {
        "x": 32,
        "y": 64,
        "w": 32,
        "h": 32
      }
    },
    {
      "name": "sprite-10",
      "position": {
        "x": 64,
        "y": 64,
        "w": 32,
        "h": 32
      }
    },
    {
      "name": "sprite-11",
      "position": {
        "x": 96,
        "y": 64,
        "w": 32,
        "h": 32
      }
    }
  ]
}
```

Maybe something similar will work for you, if you used piskel.

I'm going to make my output image bigger on my canvas, by adding a size property to my Sprite:

```
class Sprite {
  constructor(animation, x, y, size, speed) {
    this.x = x;
    this.y = y;
    this.animation = animation;
    this.w = this.animation[0].width;
    this.len = this.animation.length;
    this.speed = speed;
    this.index = 0;
    this.size = size;
  }


  //notice the use of modulo to keeop the value of index in range of the number of images, ie this.len.....
  show() {
    let index = floor(this.index) % this.len;
    image(this.animation[index], this.x, this.y, this.size, this.size);
  }

  animate() {
    //increment the index and the position of x
    this.index += this.speed;

  }
}

```

and then setting it kind of big, when I make my sprite:

```
abstract = new Sprite(animation, 100, 100, 320, 0.25);

```

Maybe I should bring back this idea of an array of these things:

```

function setup() {
  createCanvas(640, 480);

  //this is the array from our JSON file
  let frames = spritedata.frames;

//now we loop over the array data and load each image into an array called animation
  for (let i = 0; i < frames.length; i++) {
    let pos = frames[i].position;
    let img = spritesheet.get(pos.x, pos.y, pos.w, pos.h);
    animation.push(img);
  }

  //make an instance of the Sprite class
  // abstract = new Sprite(animation, 100, 100, 320, 0.25);

  for (let i = 0; i < 5; i++) {
    abstractions[i] = new Sprite(animation, i * 100, 100, 160, random(0.1, 0.4));
  }
}

function draw() {
  background(0);

  //use the sprite class to show and animate the spritesheet
  // abstract.show();
  // abstract.animate();


  for (let abstraction of abstractions) {
    abstraction.show();
    abstraction.animate();
  }

  // image(animation[frameCount % animation.length], 0, 0);
}

```

Or maybe even use a two dimensional array to make a grid of them! Like [here](https://github.com/socalledsound/SE-unit2-day13-spritesheet/tree/mySprite2DArray).

And that's that!

Ok now, I have a confession to make. There's an easier way to do this. And that's to use a library called p5.play, which you can download [here](https://molleindustria.github.io/p5.play/).

I wanted use to work through this sprite sheet thing without it because I think it shows some important and very useful things in coding and in particular coding with javascript. But, it's definitely (usually) easier to do this stuff using p5.play. I'll show you how now.

Here's a p5.play [starter](https://github.com/socalledsound/SE-unit2-day13-p5play), with the p5.play library and some assets.

So first off, let's use it to create a looping animation from a set of images, just like we did above, but this time with p5.play. We use a function called loadAnimation, like this, feeding in the start and end of a set of sequentially numbered images.

```
alien = loadAnimation('img/alien0.png', 'img/alien21.png');

```

and then in our draw loop all we have to do is call a function called animation() and give your animation x and y coordinates:

```
function draw() {
  background(255, 255, 255);
    animation(alien, 400, 100);
}

```

You can see that code [here](https://github.com/socalledsound/SE-unit2-day13-p5play/tree/01-animation1).

Easy, huh? P5. play is nice. It makes a lot of things easier.

Similarly, loading a sprite sheet using p5.play is super easy:

```
  mySpritesheet = loadSpriteSheet('abstract/abstract.png', 32, 32, 12);
  myAnimation = loadAnimation(mySpritesheet);

```

and then, just the same as before, play the animation in the draw loop:

```
  animation(myAnimation, 100, 250);

```

And, you can see that code [here](https://github.com/socalledsound/SE-unit2-day13-p5play/tree/02-spritesheet).

So, that's a lot easier, right? But, with some tradeoffs, in terms of control. But there are some useful methods you can call to alter your animation, though, a full list is at the p5.play [reference](https://molleindustria.github.io/p5.play/docs/index.html).

You can see some sketches I made using p5.play in the links on today's syllabus page.

p5.play is maintained by one guy mostly, I think, so it's a little bit more fringe than the main p5 library, and occasionally I've run into some bugs. But I'll keep using it alongside regular old p5 for the rest of this unit, because it does help out with some things! Experiment with it if you think it can solve some problems for you.

So, what I want you to do for today's assignment is, use some or all of these tricks I've shown you today -- spritesheets, sequential animations, setTimeout and setInterval....to make an animation with your character that you like and upload it as a canvas-based website (p5 style) to the course gallery.

And, that's possibly enough for today, but I also want to show you one more thing! Which I really like, and which may or may not be useful to you right now. That thing is EASING. It can really improve your animations, and getting a sense of how it works is, I think, pretty interesting. In a way, it's similar to what we did with our pendulum, to reverse it.

This first bit of code is an adaptation of some code out of Daniel Shiffman's amazing (free) book, [the nature of code](https://natureofcode.com/book/), which is really an amazing book, that presents a lot of these ideas about physics and animation in a way that everyone can understand.

You can see my adaptation and play wit the values [here](https://editor.p5js.org/socalledsound/sketches/N-Ll8LRmO).

Let's start by making a class called CenterMover.

```

class CenterMover{
  constructor(){
    this.x = random(width);
    this.y = random(height);
    //we'll start with a velocity of zero and then create a velocity in update
    this.velocityX = 0;
    this.velocityY = 0;

    //this value scales the velocity down as it gets closer
    this.easing = 10;
  }

  update() {

    //first lets measure the distance between the ball and the center
    let centerX = width/2;
    let centerY = height/2;
    let distanceX = centerX - this.x;
    let distanceY = centerY - this.y;
    //now lets multiple that value by our scalar, that is our velocity
    this.velocityX = distanceX/this.easing;
    this.velocityY = distanceY/this.easing;

    //as always add velocity to position to get a new position
    this.x += this.velocityX;
    this.y += this.velocityY;

  }

  display() {
    stroke(0);
    strokeWeight(2);
    fill(127);
    ellipse(this.x, this.y, 48, 48);
  }
}

```

The key thing to notice is that, just like with our pendulum, we are updating the velocity of the object continuously. And, we are calculating it by dividing the distance from the center by a constant amount of easing. So....as the distance gets smaller, the velocity slows down. Nice, right?

Now in our main sketch we can do something like

```
//this sketch changes shiffman's mover class so that movers move towards the center.
//how would you rewrite it so they move towards one of the movers -- or each mover move towards the next mover????
//how would you rewrite this using array.forEach()?
//an empty array to hold our movers
let movers = [];
//here we can change the number of movers
let numMovers = 10;
function setup() {
  createCanvas(640, 360);

  //a for loop lets us create the number of movers specified in numMovers
  for(let i = 0; i < numMovers; i++){
    //for each element in the array lets make a "center mover", a mover that moves towards the center
    //notice that I changed the class 'Mover' to be a 'CenterMover'.
    //I also changed the title of the file and the corresponding link on the index.html page.
    movers[i] = new CenterMover();
  }
}

function draw() {
  background(51);
  //don't forget to update and display all of the movers in the array of movers.
  for(let i = 0; i < numMovers; i++){
  movers[i].update();
  movers[i].display();
  }
}


```

What's really nice, and natural about this movement is, it doesn't just stop, it decelerates.

You can play with some other, slightly more sophisticated easing functions in this [sketch](https://editor.p5js.org/socalledsound/sketches/mAb43xKpi) if you want to. It's very similar to the other sketch, but you can substitute various easing functions to modify the easing value.

Now, I know this has been a lot, but I want to leave you with one more sligtly more complicated [sketch](https://editor.p5js.org/socalledsound/sketches/ecrE28PMw). Look it over, I hope that the comments give you a sense of what's going on, and I'm happy to talk it over with you if you're interested! As you can see, we can use these easing functions on all kinds of values in our sketches....including color values. Which is kind of what a gradient is. Also, we can loop over location values, similar to the way that we looped over images earlier today! Using this idea, we can map out a set of locations on a screen and have an object move along the list of those locations, which is what I do in this sketch. See you next time.
